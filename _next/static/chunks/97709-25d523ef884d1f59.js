"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[97709],{97709:function(e,t,i){i.d(t,{TN:function(){return Q},ZP:function(){return K},lO:function(){return y}});var s=i(50655),r=i(12044),n=i(28041),a=i(22123),o=i(17187),c=i.n(o),l=i(66736),p=i(56186);let h="client",d=`wc@2:${h}:`,u={name:h,logger:"error"},g="WALLETCONNECT_DEEPLINK_CHOICE",y="Proposal expired",m=l.SEVEN_DAYS,w={wc_sessionPropose:{req:{ttl:l.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:l.ONE_DAY,prompt:!1,tag:1104},res:{ttl:l.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:l.ONE_DAY,prompt:!1,tag:1106},res:{ttl:l.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:l.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:l.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:l.ONE_DAY,prompt:!1,tag:1112},res:{ttl:l.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:l.ONE_DAY,prompt:!1,tag:1114},res:{ttl:l.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:l.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:l.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:l.FIVE_MINUTES,prompt:!1,tag:1119}}},_={min:l.FIVE_MINUTES,max:l.SEVEN_DAYS},E={idle:"IDLE",active:"ACTIVE"},f=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],R="wc@1.5:auth:",I=`${R}:PUB_KEY`;var S=Object.defineProperty,v=Object.defineProperties,q=Object.getOwnPropertyDescriptors,T=Object.getOwnPropertySymbols,N=Object.prototype.hasOwnProperty,P=Object.prototype.propertyIsEnumerable,b=(e,t,i)=>t in e?S(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,O=(e,t)=>{for(var i in t||(t={}))N.call(t,i)&&b(e,i,t[i]);if(T)for(var i of T(t))P.call(t,i)&&b(e,i,t[i]);return e},D=(e,t)=>v(e,q(t));class k extends n.W3{constructor(e){super(e),this.name="engine",this.events=new(c()),this.initialized=!1,this.requestQueue={state:E.idle,queue:[]},this.sessionRequestQueue={state:E.idle,queue:[]},this.requestQueueDelay=l.ONE_SECOND,this.expectedPairingMethodMap=new Map,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.relayMessageCache=[],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(w)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},(0,l.toMiliseconds)(this.requestQueueDelay)))},this.connect=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();let t=D(O({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(t);let{pairingTopic:i,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:o,relays:c}=t,p=i,h,d=!1;try{p&&(d=this.client.core.pairing.pairings.get(p).active)}catch(e){throw this.client.logger.error(`connect() -> pairing.get(${p}) failed`),e}if(!p||!d){let{topic:e,uri:t}=await this.client.core.pairing.create();p=e,h=t}if(!p){let{message:e}=(0,a.kCb)("NO_MATCHING_KEY",`connect() pairing topic: ${p}`);throw Error(e)}let u=await this.client.core.crypto.generateKeyPair(),g=w.wc_sessionPropose.req.ttl||l.FIVE_MINUTES,m=(0,a.gn4)(g),_=O({requiredNamespaces:r,optionalNamespaces:n,relays:c??[{protocol:s.ZF}],proposer:{publicKey:u,metadata:this.client.metadata},expiryTimestamp:m,pairingTopic:p},o&&{sessionProperties:o}),{reject:E,resolve:f,done:R}=(0,a.H1S)(g,y);this.events.once((0,a.E0T)("session_connect"),async({error:e,session:t})=>{if(e)E(e);else if(t){t.self.publicKey=u;let e=D(O({},t),{pairingTopic:_.pairingTopic,requiredNamespaces:_.requiredNamespaces,optionalNamespaces:_.optionalNamespaces,transportType:s.QZ.relay});await this.client.session.set(t.topic,e),await this.setExpiry(t.topic,t.expiry),p&&await this.client.core.pairing.updateMetadata({topic:p,metadata:t.peer.metadata}),this.cleanupDuplicatePairings(e),f(e)}});let I=await this.sendRequest({topic:p,method:"wc_sessionPropose",params:_,throwOnFailedPublish:!0});return await this.setProposal(I,O({id:I},_)),{uri:h,approval:R}},this.pair=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(e)}catch(e){throw this.client.logger.error("pair() failed"),e}},this.approve=async e=>{var t,i,r;let n=this.client.core.eventClient.createEvent({properties:{topic:null==(t=e?.id)?void 0:t.toString(),trace:[s.Wk.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(e){throw n.setError(s.cQ.no_internet_connection),e}try{await this.isValidProposalId(e?.id)}catch(t){throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`),n.setError(s.cQ.proposal_not_found),t}try{await this.isValidApprove(e)}catch(e){throw this.client.logger.error("approve() -> isValidApprove() failed"),n.setError(s.cQ.session_approve_namespace_validation_failure),e}let{id:o,relayProtocol:c,namespaces:l,sessionProperties:p,sessionConfig:h}=e,d=this.client.proposal.get(o);this.client.core.eventClient.deleteEvent({eventId:n.eventId});let{pairingTopic:u,proposer:g,requiredNamespaces:y,optionalNamespaces:w}=d,_=null==(i=this.client.core.eventClient)?void 0:i.getEvent({topic:u});_||(_=null==(r=this.client.core.eventClient)?void 0:r.createEvent({type:s.Wk.session_approve_started,properties:{topic:u,trace:[s.Wk.session_approve_started,s.Wk.session_namespaces_validation_success]}}));let E=await this.client.core.crypto.generateKeyPair(),f=g.publicKey,R=await this.client.core.crypto.generateSharedKey(E,f),I=O(O({relay:{protocol:c??"irn"},namespaces:l,controller:{publicKey:E,metadata:this.client.metadata},expiry:(0,a.gn4)(m)},p&&{sessionProperties:p}),h&&{sessionConfig:h}),S=s.QZ.relay;_.addTrace(s.Wk.subscribing_session_topic);try{await this.client.core.relayer.subscribe(R,{transportType:S})}catch(e){throw _.setError(s.cQ.subscribe_session_topic_failure),e}_.addTrace(s.Wk.subscribe_session_topic_success);let v=D(O({},I),{topic:R,requiredNamespaces:y,optionalNamespaces:w,pairingTopic:u,acknowledged:!1,self:I.controller,peer:{publicKey:g.publicKey,metadata:g.metadata},controller:E,transportType:s.QZ.relay});await this.client.session.set(R,v),_.addTrace(s.Wk.store_session);try{_.addTrace(s.Wk.publishing_session_settle),await this.sendRequest({topic:R,method:"wc_sessionSettle",params:I,throwOnFailedPublish:!0}).catch(e=>{throw _?.setError(s.cQ.session_settle_publish_failure),e}),_.addTrace(s.Wk.session_settle_publish_success),_.addTrace(s.Wk.publishing_session_approve),await this.sendResult({id:o,topic:u,result:{relay:{protocol:c??"irn"},responderPublicKey:E},throwOnFailedPublish:!0}).catch(e=>{throw _?.setError(s.cQ.session_approve_publish_failure),e}),_.addTrace(s.Wk.session_approve_publish_success)}catch(e){throw this.client.logger.error(e),this.client.session.delete(R,(0,a.D6H)("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(R),e}return this.client.core.eventClient.deleteEvent({eventId:_.eventId}),await this.client.core.pairing.updateMetadata({topic:u,metadata:g.metadata}),await this.client.proposal.delete(o,(0,a.D6H)("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:u}),await this.setExpiry(R,(0,a.gn4)(m)),{topic:R,acknowledged:()=>Promise.resolve(this.client.session.get(R))}},this.reject=async e=>{let t;this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(e)}catch(e){throw this.client.logger.error("reject() -> isValidReject() failed"),e}let{id:i,reason:s}=e;try{t=this.client.proposal.get(i).pairingTopic}catch(e){throw this.client.logger.error(`reject() -> proposal.get(${i}) failed`),e}t&&(await this.sendError({id:i,topic:t,error:s,rpcOpts:w.wc_sessionPropose.reject}),await this.client.proposal.delete(i,(0,a.D6H)("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(e)}catch(e){throw this.client.logger.error("update() -> isValidUpdate() failed"),e}let{topic:t,namespaces:i}=e,{done:s,resolve:r,reject:n}=(0,a.H1S)(),o=(0,p.payloadId)(),c=(0,p.getBigIntRpcId)().toString(),l=this.client.session.get(t).namespaces;return this.events.once((0,a.E0T)("session_update",o),({error:e})=>{e?n(e):r()}),await this.client.session.update(t,{namespaces:i}),await this.sendRequest({topic:t,method:"wc_sessionUpdate",params:{namespaces:i},throwOnFailedPublish:!0,clientRpcId:o,relayRpcId:c}).catch(e=>{this.client.logger.error(e),this.client.session.update(t,{namespaces:l}),n(e)}),{acknowledged:s}},this.extend=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(e)}catch(e){throw this.client.logger.error("extend() -> isValidExtend() failed"),e}let{topic:t}=e,i=(0,p.payloadId)(),{done:s,resolve:r,reject:n}=(0,a.H1S)();return this.events.once((0,a.E0T)("session_extend",i),({error:e})=>{e?n(e):r()}),await this.setExpiry(t,(0,a.gn4)(m)),this.sendRequest({topic:t,method:"wc_sessionExtend",params:{},clientRpcId:i,throwOnFailedPublish:!0}).catch(e=>{n(e)}),{acknowledged:s}},this.request=async e=>{this.isInitialized();try{await this.isValidRequest(e)}catch(e){throw this.client.logger.error("request() -> isValidRequest() failed"),e}let{chainId:t,request:i,topic:r,expiry:n=w.wc_sessionRequest.req.ttl}=e,o=this.client.session.get(r);o?.transportType===s.QZ.relay&&await this.confirmOnlineStateOrThrow();let c=(0,p.payloadId)(),l=(0,p.getBigIntRpcId)().toString(),{done:h,resolve:d,reject:u}=(0,a.H1S)(n,"Request expired. Please try again.");this.events.once((0,a.E0T)("session_request",c),({error:e,result:t})=>{e?u(e):d(t)});let y=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);return y?(await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:"wc_sessionRequest",params:{request:D(O({},i),{expiryTimestamp:(0,a.gn4)(n)}),chainId:t},expiry:n,throwOnFailedPublish:!0,appLink:y}).catch(e=>u(e)),this.client.events.emit("session_request_sent",{topic:r,request:i,chainId:t,id:c}),await h()):await Promise.all([new Promise(async e=>{await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:"wc_sessionRequest",params:{request:D(O({},i),{expiryTimestamp:(0,a.gn4)(n)}),chainId:t},expiry:n,throwOnFailedPublish:!0}).catch(e=>u(e)),this.client.events.emit("session_request_sent",{topic:r,request:i,chainId:t,id:c}),e()}),new Promise(async e=>{var t;if(!(null!=(t=o.sessionConfig)&&t.disableDeepLink)){let e=await (0,a.bW6)(this.client.core.storage,g);await (0,a.HhN)({id:c,topic:r,wcDeepLink:e})}e()}),h()]).then(e=>e[2])},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);let{topic:t,response:i}=e,{id:r}=i,n=this.client.session.get(t);n.transportType===s.QZ.relay&&await this.confirmOnlineStateOrThrow();let a=this.getAppLinkIfEnabled(n.peer.metadata,n.transportType);(0,p.isJsonRpcResult)(i)?await this.sendResult({id:r,topic:t,result:i.result,throwOnFailedPublish:!0,appLink:a}):(0,p.isJsonRpcError)(i)&&await this.sendError({id:r,topic:t,error:i.error,appLink:a}),this.cleanupAfterResponse(e)},this.ping=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(e)}catch(e){throw this.client.logger.error("ping() -> isValidPing() failed"),e}let{topic:t}=e;if(this.client.session.keys.includes(t)){let e=(0,p.payloadId)(),i=(0,p.getBigIntRpcId)().toString(),{done:s,resolve:r,reject:n}=(0,a.H1S)();this.events.once((0,a.E0T)("session_ping",e),({error:e})=>{e?n(e):r()}),await Promise.all([this.sendRequest({topic:t,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:e,relayRpcId:i}),s()])}else this.client.core.pairing.pairings.keys.includes(t)&&await this.client.core.pairing.ping({topic:t})},this.emit=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(e);let{topic:t,event:i,chainId:s}=e,r=(0,p.getBigIntRpcId)().toString();await this.sendRequest({topic:t,method:"wc_sessionEvent",params:{event:i,chainId:s},throwOnFailedPublish:!0,relayRpcId:r})},this.disconnect=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(e);let{topic:t}=e;if(this.client.session.keys.includes(t))await this.sendRequest({topic:t,method:"wc_sessionDelete",params:(0,a.D6H)("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:t,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(t))await this.client.core.pairing.disconnect({topic:t});else{let{message:e}=(0,a.kCb)("MISMATCHED_TOPIC",`Session or pairing topic not found: ${t}`);throw Error(e)}},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(t=>(0,a.Ih8)(t,e))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.authenticate=async(e,t)=>{var i;let r;this.isInitialized(),this.isValidAuthenticate(e);let n=t&&this.client.core.linkModeSupportedApps.includes(t)&&(null==(i=this.client.metadata.redirect)?void 0:i.linkMode),o=n?s.QZ.link_mode:s.QZ.relay;o===s.QZ.relay&&await this.confirmOnlineStateOrThrow();let{chains:c,statement:l="",uri:h,domain:d,nonce:u,type:g,exp:y,nbf:_,methods:E=[],expiry:f}=e,R=[...e.resources||[]],{topic:S,uri:v}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:o});this.client.logger.info({message:"Generated new pairing",pairing:{topic:S,uri:v}});let q=await this.client.core.crypto.generateKeyPair(),T=(0,a.YmJ)(q);if(await Promise.all([this.client.auth.authKeys.set(I,{responseTopic:T,publicKey:q}),this.client.auth.pairingTopics.set(T,{topic:T,pairingTopic:S})]),await this.client.core.relayer.subscribe(T,{transportType:o}),this.client.logger.info(`sending request to new pairing topic: ${S}`),E.length>0){let{namespace:e}=(0,a.DQe)(c[0]),t=(0,a.IkP)(e,"request",E);(0,a.hA9)(R)&&(t=(0,a.qJM)(t,R.pop())),R.push(t)}let N=f&&f>w.wc_sessionAuthenticate.req.ttl?f:w.wc_sessionAuthenticate.req.ttl,P={authPayload:{type:g??"caip122",chains:c,statement:l,aud:h,domain:d,version:"1",nonce:u,iat:new Date().toISOString(),exp:y,nbf:_,resources:R},requester:{publicKey:q,metadata:this.client.metadata},expiryTimestamp:(0,a.gn4)(N)},b={requiredNamespaces:{},optionalNamespaces:{eip155:{chains:c,methods:[...new Set(["personal_sign",...E])],events:["chainChanged","accountsChanged"]}},relays:[{protocol:"irn"}],pairingTopic:S,proposer:{publicKey:q,metadata:this.client.metadata},expiryTimestamp:(0,a.gn4)(w.wc_sessionPropose.req.ttl)},{done:k,resolve:C,reject:M}=(0,a.H1S)(N,"Request expired"),A=async({error:e,session:t})=>{if(this.events.off((0,a.E0T)("session_request",V),x),e)M(e);else if(t){t.self.publicKey=q,await this.client.session.set(t.topic,t),await this.setExpiry(t.topic,t.expiry),S&&await this.client.core.pairing.updateMetadata({topic:S,metadata:t.peer.metadata});let e=this.client.session.get(t.topic);await this.deleteProposal(L),C({session:e})}},x=async e=>{var i,r,n;let c;if(await this.deletePendingAuthRequest(V,{message:"fulfilled",code:0}),e.error){let t=(0,a.D6H)("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return e.error.code===t.code?void 0:(this.events.off((0,a.E0T)("session_connect"),A),M(e.error.message))}await this.deleteProposal(L),this.events.off((0,a.E0T)("session_connect"),A);let{cacaos:l,responder:p}=e.result,h=[],d=[];for(let e of l){await (0,a.c4l)({cacao:e,projectId:this.client.core.projectId})||(this.client.logger.error(e,"Signature verification failed"),M((0,a.D6H)("SESSION_SETTLEMENT_FAILED","Signature verification failed")));let{p:t}=e,i=(0,a.hA9)(t.resources),s=[(0,a.DJo)(t.iss)],r=(0,a.NmC)(t.iss);if(i){let e=(0,a.Y31)(i),t=(0,a.ouN)(i);h.push(...e),s.push(...t)}for(let e of s)d.push(`${e}:${r}`)}let u=await this.client.core.crypto.generateSharedKey(q,p.publicKey);h.length>0&&(c={topic:u,acknowledged:!0,self:{publicKey:q,metadata:this.client.metadata},peer:p,controller:p.publicKey,expiry:(0,a.gn4)(m),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:S,namespaces:(0,a.E12)([...new Set(h)],[...new Set(d)]),transportType:o},await this.client.core.relayer.subscribe(u,{transportType:o}),await this.client.session.set(u,c),S&&await this.client.core.pairing.updateMetadata({topic:S,metadata:p.metadata}),c=this.client.session.get(u)),null!=(i=this.client.metadata.redirect)&&i.linkMode&&null!=(r=p.metadata.redirect)&&r.linkMode&&null!=(n=p.metadata.redirect)&&n.universal&&t&&(this.client.core.addLinkModeSupportedApp(p.metadata.redirect.universal),this.client.session.update(u,{transportType:s.QZ.link_mode})),C({auths:l,session:c})},V=(0,p.payloadId)(),L=(0,p.payloadId)();this.events.once((0,a.E0T)("session_connect"),A),this.events.once((0,a.E0T)("session_request",V),x);try{if(n){let e=(0,p.formatJsonRpcRequest)("wc_sessionAuthenticate",P,V);this.client.core.history.set(S,e);let i=await this.client.core.crypto.encode("",e,{type:a.FpL,encoding:a.zl_});r=(0,a.L9d)(t,S,i)}else await Promise.all([this.sendRequest({topic:S,method:"wc_sessionAuthenticate",params:P,expiry:e.expiry,throwOnFailedPublish:!0,clientRpcId:V}),this.sendRequest({topic:S,method:"wc_sessionPropose",params:b,expiry:w.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:L})])}catch(e){throw this.events.off((0,a.E0T)("session_connect"),A),this.events.off((0,a.E0T)("session_request",V),x),e}return await this.setProposal(L,O({id:L},b)),await this.setAuthRequest(V,{request:D(O({},P),{verifyContext:{}}),pairingTopic:S,transportType:o}),{uri:r??v,response:k}},this.approveSessionAuthenticate=async e=>{let t;let{id:i,auths:r}=e,n=this.client.core.eventClient.createEvent({properties:{topic:i.toString(),trace:[s.t7.authenticated_session_approve_started]}});try{this.isInitialized()}catch(e){throw n.setError(s.E9.no_internet_connection),e}let o=this.getPendingAuthRequest(i);if(!o)throw n.setError(s.E9.authenticated_session_pending_request_not_found),Error(`Could not find pending auth request with id ${i}`);let c=o.transportType||s.QZ.relay;c===s.QZ.relay&&await this.confirmOnlineStateOrThrow();let l=o.requester.publicKey,p=await this.client.core.crypto.generateKeyPair(),h=(0,a.YmJ)(l),d={type:a.rVF,receiverPublicKey:l,senderPublicKey:p},u=[],g=[];for(let e of r){if(!await (0,a.c4l)({cacao:e,projectId:this.client.core.projectId})){n.setError(s.E9.invalid_cacao);let e=(0,a.D6H)("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:i,topic:h,error:e,encodeOpts:d}),Error(e.message)}n.addTrace(s.t7.cacaos_verified);let{p:t}=e,r=(0,a.hA9)(t.resources),o=[(0,a.DJo)(t.iss)],c=(0,a.NmC)(t.iss);if(r){let e=(0,a.Y31)(r),t=(0,a.ouN)(r);u.push(...e),o.push(...t)}for(let e of o)g.push(`${e}:${c}`)}let y=await this.client.core.crypto.generateSharedKey(p,l);if(n.addTrace(s.t7.create_authenticated_session_topic),u?.length>0){t={topic:y,acknowledged:!0,self:{publicKey:p,metadata:this.client.metadata},peer:{publicKey:l,metadata:o.requester.metadata},controller:l,expiry:(0,a.gn4)(m),authentication:r,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:o.pairingTopic,namespaces:(0,a.E12)([...new Set(u)],[...new Set(g)]),transportType:c},n.addTrace(s.t7.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(y,{transportType:c})}catch(e){throw n.setError(s.E9.subscribe_authenticated_session_topic_failure),e}n.addTrace(s.t7.subscribe_authenticated_session_topic_success),await this.client.session.set(y,t),n.addTrace(s.t7.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:o.pairingTopic,metadata:o.requester.metadata})}n.addTrace(s.t7.publishing_authenticated_session_approve);try{await this.sendResult({topic:h,id:i,result:{cacaos:r,responder:{publicKey:p,metadata:this.client.metadata}},encodeOpts:d,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(o.requester.metadata,c)})}catch(e){throw n.setError(s.E9.authenticated_session_approve_publish_failure),e}return await this.client.auth.requests.delete(i,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:o.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:n.eventId}),{session:t}},this.rejectSessionAuthenticate=async e=>{this.isInitialized();let{id:t,reason:i}=e,r=this.getPendingAuthRequest(t);if(!r)throw Error(`Could not find pending auth request with id ${t}`);r.transportType===s.QZ.relay&&await this.confirmOnlineStateOrThrow();let n=r.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),c=(0,a.YmJ)(n),l={type:a.rVF,receiverPublicKey:n,senderPublicKey:o};await this.sendError({id:t,topic:c,error:i,encodeOpts:l,rpcOpts:w.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(r.requester.metadata,r.transportType)}),await this.client.auth.requests.delete(t,{message:"rejected",code:0}),await this.client.proposal.delete(t,(0,a.D6H)("USER_DISCONNECTED"))},this.formatAuthMessage=e=>{this.isInitialized();let{request:t,iss:i}=e;return(0,a.wvx)(t,i)},this.processRelayMessageCache=()=>{setTimeout(async()=>{if(0!==this.relayMessageCache.length)for(;this.relayMessageCache.length>0;)try{let e=this.relayMessageCache.shift();e&&await this.onRelayMessage(e)}catch(e){this.client.logger.error(e)}},50)},this.cleanupDuplicatePairings=async e=>{if(e.pairingTopic)try{let t=this.client.core.pairing.pairings.get(e.pairingTopic),i=this.client.core.pairing.pairings.getAll().filter(i=>{var s,r;return(null==(s=i.peerMetadata)?void 0:s.url)&&(null==(r=i.peerMetadata)?void 0:r.url)===e.peer.metadata.url&&i.topic&&i.topic!==t.topic});if(0===i.length)return;this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`),await Promise.all(i.map(e=>this.client.core.pairing.disconnect({topic:e.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}},this.deleteSession=async e=>{var t;let{topic:i,expirerHasDeleted:s=!1,emitEvent:r=!0,id:n=0}=e,{self:o}=this.client.session.get(i);await this.client.core.relayer.unsubscribe(i),await this.client.session.delete(i,(0,a.D6H)("USER_DISCONNECTED")),this.addToRecentlyDeleted(i,"session"),this.client.core.crypto.keychain.has(o.publicKey)&&await this.client.core.crypto.deleteKeyPair(o.publicKey),this.client.core.crypto.keychain.has(i)&&await this.client.core.crypto.deleteSymKey(i),s||this.client.core.expirer.del(i),this.client.core.storage.removeItem(g).catch(e=>this.client.logger.warn(e)),this.getPendingSessionRequests().forEach(e=>{e.topic===i&&this.deletePendingSessionRequest(e.id,(0,a.D6H)("USER_DISCONNECTED"))}),i===(null==(t=this.sessionRequestQueue.queue[0])?void 0:t.topic)&&(this.sessionRequestQueue.state=E.idle),r&&this.client.events.emit("session_delete",{id:n,topic:i})},this.deleteProposal=async(e,t)=>{if(t)try{let t=this.client.proposal.get(e),i=this.client.core.eventClient.getEvent({topic:t.pairingTopic});i?.setError(s.cQ.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(e,(0,a.D6H)("USER_DISCONNECTED")),t?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"proposal")},this.deletePendingSessionRequest=async(e,t,i=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,t),i?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(t=>t.id!==e),i&&(this.sessionRequestQueue.state=E.idle,this.client.events.emit("session_request_expire",{id:e}))},this.deletePendingAuthRequest=async(e,t,i=!1)=>{await Promise.all([this.client.auth.requests.delete(e,t),i?Promise.resolve():this.client.core.expirer.del(e)])},this.setExpiry=async(e,t)=>{this.client.session.keys.includes(e)&&(this.client.core.expirer.set(e,t),await this.client.session.update(e,{expiry:t}))},this.setProposal=async(e,t)=>{this.client.core.expirer.set(e,(0,a.gn4)(w.wc_sessionPropose.req.ttl)),await this.client.proposal.set(e,t)},this.setAuthRequest=async(e,t)=>{let{request:i,pairingTopic:r,transportType:n=s.QZ.relay}=t;this.client.core.expirer.set(e,i.expiryTimestamp),await this.client.auth.requests.set(e,{authPayload:i.authPayload,requester:i.requester,expiryTimestamp:i.expiryTimestamp,id:e,pairingTopic:r,verifyContext:i.verifyContext,transportType:n})},this.setPendingSessionRequest=async e=>{let{id:t,topic:i,params:s,verifyContext:r}=e,n=s.request.expiryTimestamp||(0,a.gn4)(w.wc_sessionRequest.req.ttl);this.client.core.expirer.set(t,n),await this.client.pendingRequest.set(t,{id:t,topic:i,params:s,verifyContext:r})},this.sendRequest=async e=>{let t,s;let{topic:r,method:n,params:o,expiry:c,relayRpcId:l,clientRpcId:h,throwOnFailedPublish:d,appLink:u}=e,g=(0,p.formatJsonRpcRequest)(n,o,h),y=!!u;try{let e=y?a.zl_:a.$dT;t=await this.client.core.crypto.encode(r,g,{encoding:e})}catch(e){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${r} failed`),e}if(f.includes(n)){let e=(0,a.rjm)(JSON.stringify(g)),i=(0,a.rjm)(t);s=await this.client.core.verify.register({id:i,decryptedId:e})}let m=w[n].req;if(m.attestation=s,c&&(m.ttl=c),l&&(m.id=l),this.client.core.history.set(r,g),y){let e=(0,a.L9d)(u,r,t);await i.g.Linking.openURL(e,this.client.name)}else{let e=w[n].req;c&&(e.ttl=c),l&&(e.id=l),d?(e.internal=D(O({},e.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(r,t,e)):this.client.core.relayer.publish(r,t,e).catch(e=>this.client.logger.error(e))}return g.id},this.sendResult=async e=>{let t,s;let{id:r,topic:n,result:o,throwOnFailedPublish:c,encodeOpts:l,appLink:h}=e,d=(0,p.formatJsonRpcResult)(r,o),u=h&&"u">typeof(null==i.g?void 0:i.g.Linking);try{let e=u?a.zl_:a.$dT;t=await this.client.core.crypto.encode(n,d,D(O({},l||{}),{encoding:e}))}catch(e){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${n} failed`),e}try{s=await this.client.core.history.get(n,r)}catch(e){throw this.client.logger.error(`sendResult() -> history.get(${n}, ${r}) failed`),e}if(u){let e=(0,a.L9d)(h,n,t);await i.g.Linking.openURL(e,this.client.name)}else{let e=w[s.request.method].res;c?(e.internal=D(O({},e.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(n,t,e)):this.client.core.relayer.publish(n,t,e).catch(e=>this.client.logger.error(e))}await this.client.core.history.resolve(d)},this.sendError=async e=>{let t,s;let{id:r,topic:n,error:o,encodeOpts:c,rpcOpts:l,appLink:h}=e,d=(0,p.formatJsonRpcError)(r,o),u=h&&"u">typeof(null==i.g?void 0:i.g.Linking);try{let e=u?a.zl_:a.$dT;t=await this.client.core.crypto.encode(n,d,D(O({},c||{}),{encoding:e}))}catch(e){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${n} failed`),e}try{s=await this.client.core.history.get(n,r)}catch(e){throw this.client.logger.error(`sendError() -> history.get(${n}, ${r}) failed`),e}if(u){let e=(0,a.L9d)(h,n,t);await i.g.Linking.openURL(e,this.client.name)}else{let e=l||w[s.request.method].res;this.client.core.relayer.publish(n,t,e)}await this.client.core.history.resolve(d)},this.cleanup=async()=>{let e=[],t=[];this.client.session.getAll().forEach(t=>{let i=!1;(0,a.BwD)(t.expiry)&&(i=!0),this.client.core.crypto.keychain.has(t.topic)||(i=!0),i&&e.push(t.topic)}),this.client.proposal.getAll().forEach(e=>{(0,a.BwD)(e.expiryTimestamp)&&t.push(e.id)}),await Promise.all([...e.map(e=>this.deleteSession({topic:e})),...t.map(e=>this.deleteProposal(e))])},this.onRelayEventRequest=async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===E.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=E.active;let e=this.requestQueue.queue.shift();if(e)try{await this.processRequest(e)}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=E.idle},this.processRequest=async e=>{let{topic:t,payload:i,attestation:s,transportType:r,encryptedId:n}=e,a=i.method;if(!this.shouldIgnorePairingRequest({topic:t,requestMethod:a}))switch(a){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:t,payload:i,attestation:s,encryptedId:n});case"wc_sessionSettle":return await this.onSessionSettleRequest(t,i);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(t,i);case"wc_sessionExtend":return await this.onSessionExtendRequest(t,i);case"wc_sessionPing":return await this.onSessionPingRequest(t,i);case"wc_sessionDelete":return await this.onSessionDeleteRequest(t,i);case"wc_sessionRequest":return await this.onSessionRequest({topic:t,payload:i,attestation:s,encryptedId:n,transportType:r});case"wc_sessionEvent":return await this.onSessionEventRequest(t,i);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:t,payload:i,attestation:s,encryptedId:n,transportType:r});default:return this.client.logger.info(`Unsupported request method ${a}`)}},this.onRelayEventResponse=async e=>{let{topic:t,payload:i,transportType:s}=e,r=(await this.client.core.history.get(t,i.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(t,i,s);case"wc_sessionSettle":return this.onSessionSettleResponse(t,i);case"wc_sessionUpdate":return this.onSessionUpdateResponse(t,i);case"wc_sessionExtend":return this.onSessionExtendResponse(t,i);case"wc_sessionPing":return this.onSessionPingResponse(t,i);case"wc_sessionRequest":return this.onSessionRequestResponse(t,i);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(t,i);default:return this.client.logger.info(`Unsupported response method ${r}`)}},this.onRelayEventUnknownPayload=e=>{let{topic:t}=e,{message:i}=(0,a.kCb)("MISSING_OR_INVALID",`Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);throw Error(i)},this.shouldIgnorePairingRequest=e=>{let{topic:t,requestMethod:i}=e,s=this.expectedPairingMethodMap.get(t);return!(!s||s.includes(i))&&!!(s.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)},this.onSessionProposeRequest=async e=>{let{topic:t,payload:i,attestation:r,encryptedId:n}=e,{params:o,id:c}=i;try{let e=this.client.core.eventClient.getEvent({topic:t});this.isValidConnect(O({},i.params));let l=o.expiryTimestamp||(0,a.gn4)(w.wc_sessionPropose.req.ttl),p=O({id:c,pairingTopic:t,expiryTimestamp:l},o);await this.setProposal(c,p);let h=await this.getVerifyContext({attestationId:r,hash:(0,a.rjm)(JSON.stringify(i)),encryptedId:n,metadata:p.proposer.metadata});0===this.client.events.listenerCount("session_proposal")&&(console.warn("No listener for session_proposal event"),e?.setError(s.jb.proposal_listener_not_found)),e?.addTrace(s.ne.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:p,verifyContext:h})}catch(e){await this.sendError({id:c,topic:t,error:e,rpcOpts:w.wc_sessionPropose.autoReject}),this.client.logger.error(e)}},this.onSessionProposeResponse=async(e,t,i)=>{let{id:s}=t;if((0,p.isJsonRpcResult)(t)){let{result:r}=t;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});let n=this.client.proposal.get(s);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});let a=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});let o=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:o});let c=await this.client.core.crypto.generateSharedKey(a,o);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:c});let l=await this.client.core.relayer.subscribe(c,{transportType:i});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:l}),await this.client.core.pairing.activate({topic:e})}else if((0,p.isJsonRpcError)(t)){await this.client.proposal.delete(s,(0,a.D6H)("USER_DISCONNECTED"));let e=(0,a.E0T)("session_connect");if(0===this.events.listenerCount(e))throw Error(`emitting ${e} without any listeners, 954`);this.events.emit((0,a.E0T)("session_connect"),{error:t.error})}},this.onSessionSettleRequest=async(e,t)=>{let{id:i,params:r}=t;try{this.isValidSessionSettleRequest(r);let{relay:i,controller:n,expiry:o,namespaces:c,sessionProperties:l,sessionConfig:p}=t.params,h=D(O(O({topic:e,relay:i,expiry:o,namespaces:c,acknowledged:!0,pairingTopic:"",requiredNamespaces:{},optionalNamespaces:{},controller:n.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:n.publicKey,metadata:n.metadata}},l&&{sessionProperties:l}),p&&{sessionConfig:p}),{transportType:s.QZ.relay}),d=(0,a.E0T)("session_connect");if(0===this.events.listenerCount(d))throw Error(`emitting ${d} without any listeners 997`);this.events.emit((0,a.E0T)("session_connect"),{session:h}),await this.sendResult({id:t.id,topic:e,result:!0,throwOnFailedPublish:!0})}catch(t){await this.sendError({id:i,topic:e,error:t}),this.client.logger.error(t)}},this.onSessionSettleResponse=async(e,t)=>{let{id:i}=t;(0,p.isJsonRpcResult)(t)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit((0,a.E0T)("session_approve",i),{})):(0,p.isJsonRpcError)(t)&&(await this.client.session.delete(e,(0,a.D6H)("USER_DISCONNECTED")),this.events.emit((0,a.E0T)("session_approve",i),{error:t.error}))},this.onSessionUpdateRequest=async(e,t)=>{let{params:i,id:s}=t;try{let t=`${e}_session_update`,r=a.O6B.get(t);if(r&&this.isRequestOutOfSync(r,s)){this.client.logger.info(`Discarding out of sync request - ${s}`),this.sendError({id:s,topic:e,error:(0,a.D6H)("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(O({topic:e},i));try{a.O6B.set(t,s),await this.client.session.update(e,{namespaces:i.namespaces}),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0})}catch(e){throw a.O6B.delete(t),e}this.client.events.emit("session_update",{id:s,topic:e,params:i})}catch(t){await this.sendError({id:s,topic:e,error:t}),this.client.logger.error(t)}},this.isRequestOutOfSync=(e,t)=>parseInt(t.toString().slice(0,-3))<=parseInt(e.toString().slice(0,-3)),this.onSessionUpdateResponse=(e,t)=>{let{id:i}=t,s=(0,a.E0T)("session_update",i);if(0===this.events.listenerCount(s))throw Error(`emitting ${s} without any listeners`);(0,p.isJsonRpcResult)(t)?this.events.emit((0,a.E0T)("session_update",i),{}):(0,p.isJsonRpcError)(t)&&this.events.emit((0,a.E0T)("session_update",i),{error:t.error})},this.onSessionExtendRequest=async(e,t)=>{let{id:i}=t;try{this.isValidExtend({topic:e}),await this.setExpiry(e,(0,a.gn4)(m)),await this.sendResult({id:i,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:i,topic:e})}catch(t){await this.sendError({id:i,topic:e,error:t}),this.client.logger.error(t)}},this.onSessionExtendResponse=(e,t)=>{let{id:i}=t,s=(0,a.E0T)("session_extend",i);if(0===this.events.listenerCount(s))throw Error(`emitting ${s} without any listeners`);(0,p.isJsonRpcResult)(t)?this.events.emit((0,a.E0T)("session_extend",i),{}):(0,p.isJsonRpcError)(t)&&this.events.emit((0,a.E0T)("session_extend",i),{error:t.error})},this.onSessionPingRequest=async(e,t)=>{let{id:i}=t;try{this.isValidPing({topic:e}),await this.sendResult({id:i,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:i,topic:e})}catch(t){await this.sendError({id:i,topic:e,error:t}),this.client.logger.error(t)}},this.onSessionPingResponse=(e,t)=>{let{id:i}=t,s=(0,a.E0T)("session_ping",i);if(0===this.events.listenerCount(s))throw Error(`emitting ${s} without any listeners`);setTimeout(()=>{(0,p.isJsonRpcResult)(t)?this.events.emit((0,a.E0T)("session_ping",i),{}):(0,p.isJsonRpcError)(t)&&this.events.emit((0,a.E0T)("session_ping",i),{error:t.error})},500)},this.onSessionDeleteRequest=async(e,t)=>{let{id:i}=t;try{this.isValidDisconnect({topic:e,reason:t.params}),Promise.all([new Promise(t=>{this.client.core.relayer.once(s.Mb.publish,async()=>{t(await this.deleteSession({topic:e,id:i}))})}),this.sendResult({id:i,topic:e,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:e,error:(0,a.D6H)("USER_DISCONNECTED")})]).catch(e=>this.client.logger.error(e))}catch(e){this.client.logger.error(e)}},this.onSessionRequest=async e=>{var t,i,r;let{topic:n,payload:o,attestation:c,encryptedId:l,transportType:h}=e,{id:d,params:u}=o;try{await this.isValidRequest(O({topic:n},u));let e=this.client.session.get(n),o=await this.getVerifyContext({attestationId:c,hash:(0,a.rjm)(JSON.stringify((0,p.formatJsonRpcRequest)("wc_sessionRequest",u,d))),encryptedId:l,metadata:e.peer.metadata,transportType:h}),g={id:d,topic:n,params:u,verifyContext:o};await this.setPendingSessionRequest(g),h===s.QZ.link_mode&&null!=(t=e.peer.metadata.redirect)&&t.universal&&this.client.core.addLinkModeSupportedApp(null==(i=e.peer.metadata.redirect)?void 0:i.universal),null!=(r=this.client.signConfig)&&r.disableRequestQueue?this.emitSessionRequest(g):(this.addSessionRequestToSessionRequestQueue(g),this.processSessionRequestQueue())}catch(e){await this.sendError({id:d,topic:n,error:e}),this.client.logger.error(e)}},this.onSessionRequestResponse=(e,t)=>{let{id:i}=t,s=(0,a.E0T)("session_request",i);if(0===this.events.listenerCount(s))throw Error(`emitting ${s} without any listeners`);(0,p.isJsonRpcResult)(t)?this.events.emit((0,a.E0T)("session_request",i),{result:t.result}):(0,p.isJsonRpcError)(t)&&this.events.emit((0,a.E0T)("session_request",i),{error:t.error})},this.onSessionEventRequest=async(e,t)=>{let{id:i,params:s}=t;try{let t=`${e}_session_event_${s.event.name}`,r=a.O6B.get(t);if(r&&this.isRequestOutOfSync(r,i)){this.client.logger.info(`Discarding out of sync request - ${i}`);return}this.isValidEmit(O({topic:e},s)),this.client.events.emit("session_event",{id:i,topic:e,params:s}),a.O6B.set(t,i)}catch(t){await this.sendError({id:i,topic:e,error:t}),this.client.logger.error(t)}},this.onSessionAuthenticateResponse=(e,t)=>{let{id:i}=t;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:e,payload:t}),(0,p.isJsonRpcResult)(t)?this.events.emit((0,a.E0T)("session_request",i),{result:t.result}):(0,p.isJsonRpcError)(t)&&this.events.emit((0,a.E0T)("session_request",i),{error:t.error})},this.onSessionAuthenticateRequest=async e=>{var t;let{topic:i,payload:r,attestation:n,encryptedId:o,transportType:c}=e;try{let{requester:e,authPayload:l,expiryTimestamp:p}=r.params,h=await this.getVerifyContext({attestationId:n,hash:(0,a.rjm)(JSON.stringify(r)),encryptedId:o,metadata:e.metadata,transportType:c}),d={requester:e,pairingTopic:i,id:r.id,authPayload:l,verifyContext:h,expiryTimestamp:p};await this.setAuthRequest(r.id,{request:d,pairingTopic:i,transportType:c}),c===s.QZ.link_mode&&null!=(t=e.metadata.redirect)&&t.universal&&this.client.core.addLinkModeSupportedApp(e.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:i,params:r.params,id:r.id,verifyContext:h})}catch(o){this.client.logger.error(o);let e=r.params.requester.publicKey,t=await this.client.core.crypto.generateKeyPair(),s=this.getAppLinkIfEnabled(r.params.requester.metadata,c),n={type:a.rVF,receiverPublicKey:e,senderPublicKey:t};await this.sendError({id:r.id,topic:i,error:o,encodeOpts:n,rpcOpts:w.wc_sessionAuthenticate.autoReject,appLink:s})}},this.addSessionRequestToSessionRequestQueue=e=>{this.sessionRequestQueue.queue.push(e)},this.cleanupAfterResponse=e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=E.idle,this.processSessionRequestQueue()},(0,l.toMiliseconds)(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:e,error:t})=>{let i=this.client.core.history.pending;i.length>0&&i.filter(t=>t.topic===e&&"wc_sessionRequest"===t.request.method).forEach(e=>{let i=e.request.id,s=(0,a.E0T)("session_request",i);if(0===this.events.listenerCount(s))throw Error(`emitting ${s} without any listeners`);this.events.emit((0,a.E0T)("session_request",e.request.id),{error:t})})},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===E.active){this.client.logger.info("session request queue is already active.");return}let e=this.sessionRequestQueue.queue[0];if(!e){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=E.active,this.emitSessionRequest(e)}catch(e){this.client.logger.error(e)}},this.emitSessionRequest=e=>{this.client.events.emit("session_request",e)},this.onPairingCreated=e=>{if(e.methods&&this.expectedPairingMethodMap.set(e.topic,e.methods),e.active)return;let t=this.client.proposal.getAll().find(t=>t.pairingTopic===e.topic);t&&this.onSessionProposeRequest({topic:e.topic,payload:(0,p.formatJsonRpcRequest)("wc_sessionPropose",{requiredNamespaces:t.requiredNamespaces,optionalNamespaces:t.optionalNamespaces,relays:t.relays,proposer:t.proposer,sessionProperties:t.sessionProperties},t.id)})},this.isValidConnect=async e=>{if(!(0,a.EJd)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw Error(t)}let{pairingTopic:t,requiredNamespaces:i,optionalNamespaces:s,sessionProperties:r,relays:n}=e;if((0,a.o8e)(t)||await this.isValidPairingTopic(t),!(0,a.PMr)(n,!0)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`connect() relays: ${n}`);throw Error(e)}(0,a.o8e)(i)||0===(0,a.L5o)(i)||this.validateNamespaces(i,"requiredNamespaces"),(0,a.o8e)(s)||0===(0,a.L5o)(s)||this.validateNamespaces(s,"optionalNamespaces"),(0,a.o8e)(r)||this.validateSessionProps(r,"sessionProperties")},this.validateNamespaces=(e,t)=>{let i=(0,a.naP)(e,"connect()",t);if(i)throw Error(i.message)},this.isValidApprove=async e=>{if(!(0,a.EJd)(e))throw Error((0,a.kCb)("MISSING_OR_INVALID",`approve() params: ${e}`).message);let{id:t,namespaces:i,relayProtocol:s,sessionProperties:r}=e;this.checkRecentlyDeleted(t),await this.isValidProposalId(t);let n=this.client.proposal.get(t),o=(0,a.ing)(i,"approve()");if(o)throw Error(o.message);let c=(0,a.rFo)(n.requiredNamespaces,i,"approve()");if(c)throw Error(c.message);if(!(0,a.M_r)(s,!0)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`approve() relayProtocol: ${s}`);throw Error(e)}(0,a.o8e)(r)||this.validateSessionProps(r,"sessionProperties")},this.isValidReject=async e=>{if(!(0,a.EJd)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`reject() params: ${e}`);throw Error(t)}let{id:t,reason:i}=e;if(this.checkRecentlyDeleted(t),await this.isValidProposalId(t),!(0,a.H4H)(i)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(i)}`);throw Error(e)}},this.isValidSessionSettleRequest=e=>{if(!(0,a.EJd)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw Error(t)}let{relay:t,controller:i,namespaces:s,expiry:r}=e;if(!(0,a.Z26)(t)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw Error(e)}let n=(0,a.DdM)(i,"onSessionSettleRequest()");if(n)throw Error(n.message);let o=(0,a.ing)(s,"onSessionSettleRequest()");if(o)throw Error(o.message);if((0,a.BwD)(r)){let{message:e}=(0,a.kCb)("EXPIRED","onSessionSettleRequest()");throw Error(e)}},this.isValidUpdate=async e=>{if(!(0,a.EJd)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`update() params: ${e}`);throw Error(t)}let{topic:t,namespaces:i}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);let s=this.client.session.get(t),r=(0,a.ing)(i,"update()");if(r)throw Error(r.message);let n=(0,a.rFo)(s.requiredNamespaces,i,"update()");if(n)throw Error(n.message)},this.isValidExtend=async e=>{if(!(0,a.EJd)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`extend() params: ${e}`);throw Error(t)}let{topic:t}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t)},this.isValidRequest=async e=>{if(!(0,a.EJd)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`request() params: ${e}`);throw Error(t)}let{topic:t,request:i,chainId:s,expiry:r}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);let{namespaces:n}=this.client.session.get(t);if(!(0,a.p8o)(n,s)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`request() chainId: ${s}`);throw Error(e)}if(!(0,a.hHR)(i)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`request() ${JSON.stringify(i)}`);throw Error(e)}if(!(0,a.alS)(n,s,i.method)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`request() method: ${i.method}`);throw Error(e)}if(r&&!(0,a.ONw)(r,_)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`request() expiry: ${r}. Expiry must be a number (in seconds) between ${_.min} and ${_.max}`);throw Error(e)}},this.isValidRespond=async e=>{var t;if(!(0,a.EJd)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`respond() params: ${e}`);throw Error(t)}let{topic:i,response:s}=e;try{await this.isValidSessionTopic(i)}catch(i){throw null!=(t=e?.response)&&t.id&&this.cleanupAfterResponse(e),i}if(!(0,a.JTI)(s)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(s)}`);throw Error(e)}},this.isValidPing=async e=>{if(!(0,a.EJd)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`ping() params: ${e}`);throw Error(t)}let{topic:t}=e;await this.isValidSessionOrPairingTopic(t)},this.isValidEmit=async e=>{if(!(0,a.EJd)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`emit() params: ${e}`);throw Error(t)}let{topic:t,event:i,chainId:s}=e;await this.isValidSessionTopic(t);let{namespaces:r}=this.client.session.get(t);if(!(0,a.p8o)(r,s)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`emit() chainId: ${s}`);throw Error(e)}if(!(0,a.nfW)(i)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw Error(e)}if(!(0,a.B95)(r,s,i.name)){let{message:e}=(0,a.kCb)("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw Error(e)}},this.isValidDisconnect=async e=>{if(!(0,a.EJd)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw Error(t)}let{topic:t}=e;await this.isValidSessionOrPairingTopic(t)},this.isValidAuthenticate=e=>{let{chains:t,uri:i,domain:s,nonce:r}=e;if(!Array.isArray(t)||0===t.length)throw Error("chains is required and must be a non-empty array");if(!(0,a.M_r)(i,!1))throw Error("uri is required parameter");if(!(0,a.M_r)(s,!1))throw Error("domain is required parameter");if(!(0,a.M_r)(r,!1))throw Error("nonce is required parameter");if([...new Set(t.map(e=>(0,a.DQe)(e).namespace))].length>1)throw Error("Multi-namespace requests are not supported. Please request single namespace only.");let{namespace:n}=(0,a.DQe)(t[0]);if("eip155"!==n)throw Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")},this.getVerifyContext=async e=>{let{attestationId:t,hash:i,encryptedId:r,metadata:n,transportType:a}=e,o={verified:{verifyUrl:n.verifyUrl||s.sG,validation:"UNKNOWN",origin:n.url||""}};try{if(a===s.QZ.link_mode){let e=this.getAppLinkIfEnabled(n,a);return o.verified.validation=e&&new URL(e).origin===new URL(n.url).origin?"VALID":"INVALID",o}let e=await this.client.core.verify.resolve({attestationId:t,hash:i,encryptedId:r,verifyUrl:n.verifyUrl});e&&(o.verified.origin=e.origin,o.verified.isScam=e.isScam,o.verified.validation=e.origin===new URL(n.url).origin?"VALID":"INVALID")}catch(e){this.client.logger.warn(e)}return this.client.logger.debug(`Verify context: ${JSON.stringify(o)}`),o},this.validateSessionProps=(e,t)=>{Object.values(e).forEach(e=>{if(!(0,a.M_r)(e,!1)){let{message:i}=(0,a.kCb)("MISSING_OR_INVALID",`${t} must be in Record<string, string> format. Received: ${JSON.stringify(e)}`);throw Error(i)}})},this.getPendingAuthRequest=e=>{let t=this.client.auth.requests.get(e);return"object"==typeof t?t:void 0},this.addToRecentlyDeleted=(e,t)=>{if(this.recentlyDeletedMap.set(e,t),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let e=0,t=this.recentlyDeletedLimit/2;for(let i of this.recentlyDeletedMap.keys()){if(e++>=t)break;this.recentlyDeletedMap.delete(i)}}},this.checkRecentlyDeleted=e=>{let t=this.recentlyDeletedMap.get(e);if(t){let{message:i}=(0,a.kCb)("MISSING_OR_INVALID",`Record was recently deleted - ${t}: ${e}`);throw Error(i)}},this.isLinkModeEnabled=(e,t)=>{var r,n,a,o,c,l,p,h,d;return!!e&&t===s.QZ.link_mode&&(null==(n=null==(r=this.client.metadata)?void 0:r.redirect)?void 0:n.linkMode)===!0&&(null==(o=null==(a=this.client.metadata)?void 0:a.redirect)?void 0:o.universal)!==void 0&&(null==(l=null==(c=this.client.metadata)?void 0:c.redirect)?void 0:l.universal)!==""&&(null==(p=e?.redirect)?void 0:p.universal)!==void 0&&(null==(h=e?.redirect)?void 0:h.universal)!==""&&(null==(d=e?.redirect)?void 0:d.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(e.redirect.universal)&&"u">typeof(null==i.g?void 0:i.g.Linking)},this.getAppLinkIfEnabled=(e,t)=>{var i;return this.isLinkModeEnabled(e,t)?null==(i=e?.redirect)?void 0:i.universal:void 0},this.handleLinkModeMessage=({url:e})=>{if(!e||!e.includes("wc_ev")||!e.includes("topic"))return;let t=(0,a.waw)(e,"topic")||"",i=decodeURIComponent((0,a.waw)(e,"wc_ev")||""),r=this.client.session.keys.includes(t);r&&this.client.session.update(t,{transportType:s.QZ.link_mode}),this.client.core.dispatchEnvelope({topic:t,message:i,sessionExists:r})},this.registerLinkModeListeners=async()=>{var e;if((0,a.h9F)()||(0,a.b$m)()&&null!=(e=this.client.metadata.redirect)&&e.linkMode){let e=null==i.g?void 0:i.g.Linking;if("u">typeof e){e.addEventListener("url",this.handleLinkModeMessage,this.client.name);let t=await e.getInitialURL();t&&setTimeout(()=>{this.handleLinkModeMessage({url:t})},50)}}}}isInitialized(){if(!this.initialized){let{message:e}=(0,a.kCb)("NOT_INITIALIZED",this.name);throw Error(e)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(s.Mb.message,e=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(e):this.onRelayMessage(e)})}async onRelayMessage(e){let{topic:t,message:i,attestation:r,transportType:n}=e,{publicKey:o}=this.client.auth.authKeys.keys.includes(I)?this.client.auth.authKeys.get(I):{responseTopic:void 0,publicKey:void 0},c=await this.client.core.crypto.decode(t,i,{receiverPublicKey:o,encoding:n===s.QZ.link_mode?a.zl_:a.$dT});try{(0,p.isJsonRpcRequest)(c)?(this.client.core.history.set(t,c),this.onRelayEventRequest({topic:t,payload:c,attestation:r,transportType:n,encryptedId:(0,a.rjm)(i)})):(0,p.isJsonRpcResponse)(c)?(await this.client.core.history.resolve(c),await this.onRelayEventResponse({topic:t,payload:c,transportType:n}),this.client.core.history.delete(t,c.id)):this.onRelayEventUnknownPayload({topic:t,payload:c,transportType:n})}catch(e){this.client.logger.error(e)}}registerExpirerEvents(){this.client.core.expirer.on(s.i9.expired,async e=>{let{topic:t,id:i}=(0,a.iPz)(e.target);return i&&this.client.pendingRequest.keys.includes(i)?await this.deletePendingSessionRequest(i,(0,a.kCb)("EXPIRED"),!0):i&&this.client.auth.requests.keys.includes(i)?await this.deletePendingAuthRequest(i,(0,a.kCb)("EXPIRED"),!0):void(t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):i&&(await this.deleteProposal(i,!0),this.client.events.emit("proposal_expire",{id:i})))})}registerPairingEvents(){this.client.core.pairing.events.on(s.I8.create,e=>this.onPairingCreated(e)),this.client.core.pairing.events.on(s.I8.delete,e=>{this.addToRecentlyDeleted(e.topic,"pairing")})}isValidPairingTopic(e){if(!(0,a.M_r)(e,!1)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw Error(t)}if(!this.client.core.pairing.pairings.keys.includes(e)){let{message:t}=(0,a.kCb)("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw Error(t)}if((0,a.BwD)(this.client.core.pairing.pairings.get(e).expiry)){let{message:t}=(0,a.kCb)("EXPIRED",`pairing topic: ${e}`);throw Error(t)}}async isValidSessionTopic(e){if(!(0,a.M_r)(e,!1)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`session topic should be a string: ${e}`);throw Error(t)}if(this.checkRecentlyDeleted(e),!this.client.session.keys.includes(e)){let{message:t}=(0,a.kCb)("NO_MATCHING_KEY",`session topic doesn't exist: ${e}`);throw Error(t)}if((0,a.BwD)(this.client.session.get(e).expiry)){await this.deleteSession({topic:e});let{message:t}=(0,a.kCb)("EXPIRED",`session topic: ${e}`);throw Error(t)}if(!this.client.core.crypto.keychain.has(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`session topic does not exist in keychain: ${e}`);throw await this.deleteSession({topic:e}),Error(t)}}async isValidSessionOrPairingTopic(e){if(this.checkRecentlyDeleted(e),this.client.session.keys.includes(e))await this.isValidSessionTopic(e);else if(this.client.core.pairing.pairings.keys.includes(e))this.isValidPairingTopic(e);else if((0,a.M_r)(e,!1)){let{message:t}=(0,a.kCb)("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${e}`);throw Error(t)}else{let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`session or pairing topic should be a string: ${e}`);throw Error(t)}}async isValidProposalId(e){if(!(0,a.Q01)(e)){let{message:t}=(0,a.kCb)("MISSING_OR_INVALID",`proposal id should be a number: ${e}`);throw Error(t)}if(!this.client.proposal.keys.includes(e)){let{message:t}=(0,a.kCb)("NO_MATCHING_KEY",`proposal id doesn't exist: ${e}`);throw Error(t)}if((0,a.BwD)(this.client.proposal.get(e).expiryTimestamp)){await this.deleteProposal(e);let{message:t}=(0,a.kCb)("EXPIRED",`proposal id: ${e}`);throw Error(t)}}}class C extends s.yh{constructor(e,t){super(e,t,"proposal",d),this.core=e,this.logger=t}}class M extends s.yh{constructor(e,t){super(e,t,"session",d),this.core=e,this.logger=t}}class A extends s.yh{constructor(e,t){super(e,t,"request",d,e=>e.id),this.core=e,this.logger=t}}class x extends s.yh{constructor(e,t){super(e,t,"authKeys",R,()=>I),this.core=e,this.logger=t}}class V extends s.yh{constructor(e,t){super(e,t,"pairingTopics",R),this.core=e,this.logger=t}}class L extends s.yh{constructor(e,t){super(e,t,"requests",R,e=>e.id),this.core=e,this.logger=t}}class ${constructor(e,t){this.core=e,this.logger=t,this.authKeys=new x(this.core,this.logger),this.pairingTopics=new V(this.core,this.logger),this.requests=new L(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}class K extends n.lV{constructor(e){super(e),this.protocol="wc",this.version=2,this.name=u.name,this.events=new o.EventEmitter,this.on=(e,t)=>this.events.on(e,t),this.once=(e,t)=>this.events.once(e,t),this.off=(e,t)=>this.events.off(e,t),this.removeListener=(e,t)=>this.events.removeListener(e,t),this.removeAllListeners=e=>this.events.removeAllListeners(e),this.connect=async e=>{try{return await this.engine.connect(e)}catch(e){throw this.logger.error(e.message),e}},this.pair=async e=>{try{return await this.engine.pair(e)}catch(e){throw this.logger.error(e.message),e}},this.approve=async e=>{try{return await this.engine.approve(e)}catch(e){throw this.logger.error(e.message),e}},this.reject=async e=>{try{return await this.engine.reject(e)}catch(e){throw this.logger.error(e.message),e}},this.update=async e=>{try{return await this.engine.update(e)}catch(e){throw this.logger.error(e.message),e}},this.extend=async e=>{try{return await this.engine.extend(e)}catch(e){throw this.logger.error(e.message),e}},this.request=async e=>{try{return await this.engine.request(e)}catch(e){throw this.logger.error(e.message),e}},this.respond=async e=>{try{return await this.engine.respond(e)}catch(e){throw this.logger.error(e.message),e}},this.ping=async e=>{try{return await this.engine.ping(e)}catch(e){throw this.logger.error(e.message),e}},this.emit=async e=>{try{return await this.engine.emit(e)}catch(e){throw this.logger.error(e.message),e}},this.disconnect=async e=>{try{return await this.engine.disconnect(e)}catch(e){throw this.logger.error(e.message),e}},this.find=e=>{try{return this.engine.find(e)}catch(e){throw this.logger.error(e.message),e}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}},this.authenticate=async(e,t)=>{try{return await this.engine.authenticate(e,t)}catch(e){throw this.logger.error(e.message),e}},this.formatAuthMessage=e=>{try{return this.engine.formatAuthMessage(e)}catch(e){throw this.logger.error(e.message),e}},this.approveSessionAuthenticate=async e=>{try{return await this.engine.approveSessionAuthenticate(e)}catch(e){throw this.logger.error(e.message),e}},this.rejectSessionAuthenticate=async e=>{try{return await this.engine.rejectSessionAuthenticate(e)}catch(e){throw this.logger.error(e.message),e}},this.name=e?.name||u.name,this.metadata=e?.metadata||(0,a.DaH)(),this.signConfig=e?.signConfig;let t="u">typeof e?.logger&&"string"!=typeof e?.logger?e.logger:(0,r.gw)((0,r.jI)({level:e?.logger||u.logger}));this.core=e?.core||new s.QY(e),this.logger=(0,r.Ep)(t,this.name),this.session=new M(this.core,this.logger),this.proposal=new C(this.core,this.logger),this.pendingRequest=new A(this.core,this.logger),this.engine=new k(this),this.auth=new $(this.core,this.logger)}static async init(e){let t=new K(e);return await t.initialize(),t}get context(){return(0,r.Fd)(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),this.engine.processRelayMessageCache()}catch(e){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(e.message),e}}}let Q=K}}]);